<?php
/*
 * SpoonacularAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

namespace SpoonacularAPILib\Controllers;

use SpoonacularAPILib\APIException;
use SpoonacularAPILib\APIHelper;
use SpoonacularAPILib\Configuration;
use SpoonacularAPILib\Models;
use SpoonacularAPILib\Exceptions;
use SpoonacularAPILib\Http\HttpRequest;
use SpoonacularAPILib\Http\HttpResponse;
use SpoonacularAPILib\Http\HttpMethod;
use SpoonacularAPILib\Http\HttpContext;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class APIController extends BaseController {

    /**
     * @var APIController The reference to *Singleton* instance of this class
     */
    private static $instance;
    
    /**
     * Returns the *Singleton* instance of this class.
     * @return APIController The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * Get information about a packaged food product.
     * @param  integer     $id     Required parameter: The id of the packaged food product.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProductInformation (
                $id) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/food/products/{id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'id' => $id,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Find recipes which are similar to the given one.
     * @param  integer     $id     Required parameter: The id of the source recipe to which similar recipes should be found.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function findSimilarRecipes (
                $id) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/{id}/similar';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'id' => $id,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Autocomplete a search for an ingredient.
     * @param  string     $query     Required parameter: The query - a partial or full ingredient name.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getAutocompleteIngredientSearch (
                $query) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/food/ingredients/autocomplete';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'query' => $query,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Visualize the price breakdown of a recipe.
     * @param  string      $ingredientList     Required parameter: The ingredient list of the recipe, one ingredient per line.
     * @param  integer     $servings           Required parameter: The number of servings.
     * @param  string      $defaultCss         Optional parameter: Whether the widget should be styled with the default css.
     * @param  integer     $mode               Optional parameter: The mode in which the widget should be delivered. 1 = separate views (compact), 2 = all in one view (full).
     * @param    array  $fieldParameters    Additional optional form parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createVisualizePriceBreakdown (
                $ingredientList,
                $servings,
                $defaultCss = 'checked',
                $mode = 1,
                $fieldParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/visualizePriceEstimator';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //prepare parameters
        $_parameters = array (
            'ingredientList' => $ingredientList,
            'servings'       => $servings,
            'defaultCss'     => (null != $defaultCss) ? $defaultCss : 'checked',
            'mode'           => (null != $mode) ? $mode : 1
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl, $_parameters);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Form($_parameters));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Visualize a recipe's nutritional information.
     * @param  string      $ingredientList     Required parameter: The ingredient list of the recipe, one ingredient per line.
     * @param  integer     $servings           Required parameter: The number of servings.
     * @param  string      $defaultCss         Optional parameter: Whether the ingredient list should be styled with the default css.
     * @param    array  $fieldParameters    Additional optional form parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createVisualizeNutrition (
                $ingredientList,
                $servings,
                $defaultCss = 'checked',
                $fieldParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/visualizeNutrition';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //prepare parameters
        $_parameters = array (
            'ingredientList' => $ingredientList,
            'servings'       => $servings,
            'defaultCss'     => (null != $defaultCss) ? $defaultCss : 'checked'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl, $_parameters);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Form($_parameters));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Visualize ingredients of a recipe.
     * @param  string      $ingredientList     Required parameter: The ingredient list of the recipe, one ingredient per line.
     * @param  integer     $servings           Required parameter: The initial number of servings.
     * @param  string      $defaultCss         Optional parameter: Whether the ingredient list should be styled with the default css.
     * @param  string      $measure            Optional parameter: The initial measure, either "metric" or "us".
     * @param  string      $view               Optional parameter: The initial view, either "grid" or "list".
     * @param    array  $fieldParameters    Additional optional form parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createVisualizeIngredients (
                $ingredientList,
                $servings,
                $defaultCss = 'checked',
                $measure = 'metric',
                $view = 'grid',
                $fieldParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/visualizeIngredients';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //prepare parameters
        $_parameters = array (
            'ingredientList' => $ingredientList,
            'servings'       => $servings,
            'defaultCss'     => (null != $defaultCss) ? $defaultCss : 'checked',
            'measure'        => (null != $measure) ? $measure : 'metric',
            'view'           => (null != $view) ? $view : 'grid'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl, $_parameters);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Form($_parameters));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Summarize the recipe in a short text.
     * @param  integer     $id     Required parameter: The id of the recipe that should be summarized.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getSummarizeRecipe (
                $id) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/{id}/summary';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'id' => $id,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Search packaged food products like frozen pizza and snickers bars.
     * @param  string      $query      Required parameter: The search query.
     * @param  integer     $number     Optional parameter: The number of results to retrieve, defaults to 10.
     * @param  integer     $offset     Optional parameter: The number of results to skip, defaults to 0.
     * @param  array  $queryParameters    Additional optional query parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function searchGroceryProducts (
                $query,
                $number = 10,
                $offset = 0,
                $queryParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/food/products/search';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'query'  => $query,
            'number' => (null != $number) ? $number : 10,
            'offset' => (null != $offset) ? $offset : 0,
        ));

        //append optional parameters to the query
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, $queryParameters);

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Answer a nutrition related natural language question.
     * @param  string     $q     Required parameter: The nutrition-related question.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getQuickAnswer (
                $q) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/quickAnswer';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'q' => $q,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Get information about a recipe.
     * @param  integer     $id     Required parameter: The id of the recipe.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRecipeInformation (
                $id) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/{id}/information';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'id' => $id,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Extract an ingredient from plain text.
     * @param  string      $ingredientList     Required parameter: The ingredient list of the recipe, one ingredient per line.
     * @param  integer     $servings           Required parameter: The number of servings that you can make from the ingredients.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createParseIngredients (
                $ingredientList,
                $servings) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/parseIngredients';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //prepare parameters
        $_parameters = array (
            'ingredientList' => $ingredientList,
            'servings'       => $servings
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl, $_parameters);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Form($_parameters));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Map ingredients to food products.
     * @param  string      $ingredientList     Required parameter: A new line-separated list of ingredients.
     * @param  integer     $servings           Required parameter: The number of servings this recipe makes.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createMapIngredients (
                $ingredientList,
                $servings) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/food/ingredients/map';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //prepare parameters
        $_parameters = array (
            'ingredientList' => $ingredientList,
            'servings'       => $servings
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl, $_parameters);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Form($_parameters));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Extract recipe data from a recipe blog or Web page.
     * @param  string     $url                 Required parameter: The URL of the recipe page.
     * @param  bool       $forceExtraction     Optional parameter: If true, the extraction will be triggered no matter whether we know the recipe already. Use that only if information is missing as this operation is slower.
     * @param  array  $queryParameters    Additional optional query parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getExtractRecipeFromWebsite (
                $url,
                $forceExtraction = false,
                $queryParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/extract';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'url'             => $url,
            'forceExtraction' => (null != $forceExtraction) ? var_export($forceExtraction, true) : false,
        ));

        //append optional parameters to the query
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, $queryParameters);

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Compute a meal plan for a day.
     * @param  integer     $targetCalories     Required parameter: The target number of calories per day.
     * @param  string      $timeFrame          Required parameter: For one day or a complete week, allowed values are "day" and "week".
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getComputeDailyMealPlan (
                $targetCalories,
                $timeFrame) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/mealplans/generate';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'targetCalories' => $targetCalories,
            'timeFrame'      => $timeFrame,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Given a set of product jsons, get back classified products.
     * @param  array     $productJsonArray     Required parameter: A JSON Array of products.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createClassifyGroceryProductsBatch (
                $productJsonArray) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/food/products/classifyBatch';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'     => 'APIMATIC 2.0',
            'Accept'         => 'application/json',
            'content-type'   => 'application/json; charset=utf-8',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($productJsonArray));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Classify the recipe's cuisine.
     * @param  string     $ingredientList     Required parameter: The ingredient list of the recipe, one ingredient per line.
     * @param  string     $title              Required parameter: The title of the recipe.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createClassifyCuisine (
                $ingredientList,
                $title) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/cuisine';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //prepare parameters
        $_parameters = array (
            'ingredientList' => $ingredientList,
            'title'          => $title
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl, $_parameters);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Form($_parameters));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Given a grocery product title, this endpoint allows you to detect what basic ingredient it is.
     * @param  Models\Productjson $productJson     Required parameter: The json representation of a product.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createClassifyAGroceryProduct (
                $productJson) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/food/products/classify';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($productJson));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\Classifiedproduct());
    }
        
    /**
     * Search recipes in natural language.
     * @param  string      $query                  Required parameter: The (natural language) recipe search query.
     * @param  string      $cuisine                Optional parameter: The cuisine(s) of the recipes. One or more (comma separated) of the following: african, chinese, japanese, korean, vietnamese, thai, indian, british, irish, french, italian, mexican, spanish, middle eastern, jewish, american, cajun, southern, greek, german, nordic, eastern european, caribbean, or latin american.
     * @param  string      $diet                   Optional parameter: The diet to which the recipes must be compliant. Possible values are: pescetarian, lacto vegetarian, ovo vegetarian, vegan, and vegetarian.
     * @param  string      $excludeIngredients     Optional parameter: An comma-separated list of ingredients or ingredient types that must not be contained in the recipes.
     * @param  string      $intolerances           Optional parameter: A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. Possible values are: dairy, egg, gluten, peanut, sesame, seafood, shellfish, soy, sulfite, tree nut, and wheat.
     * @param  bool        $limitLicense           Optional parameter: Whether the recipes should have an open license that allows for displaying with proper attribution.
     * @param  integer     $number                 Optional parameter: The number of results to return (between 0 and 100).
     * @param  integer     $offset                 Optional parameter: The number of results to skip (between 0 and 900).
     * @param  string      $type                   Optional parameter: The type of the recipes. One of the following: main course, side dish, dessert, appetizer, salad, bread, breakfast, soup, beverage, sauce, or drink.
     * @param  array  $queryParameters    Additional optional query parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function searchRecipes (
                $query,
                $cuisine = 'italian',
                $diet = 'vegetarian',
                $excludeIngredients = 'coconut',
                $intolerances = 'egg, gluten',
                $limitLicense = false,
                $number = 10,
                $offset = 0,
                $type = 'main course',
                $queryParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/search';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'query'              => $query,
            'cuisine'            => (null != $cuisine) ? $cuisine : 'italian',
            'diet'               => (null != $diet) ? $diet : 'vegetarian',
            'excludeIngredients' => (null != $excludeIngredients) ? $excludeIngredients : 'coconut',
            'intolerances'       => (null != $intolerances) ? $intolerances : 'egg, gluten',
            'limitLicense'       => (null != $limitLicense) ? var_export($limitLicense, true) : false,
            'number'             => (null != $number) ? $number : 10,
            'offset'             => (null != $offset) ? $offset : 0,
            'type'               => (null != $type) ? $type : 'main course',
        ));

        //append optional parameters to the query
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, $queryParameters);

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Find a set of recipes that adhere to the given nutrient limits. All the found recipes will have macro nutrients within the calories, protein, fat, and carbohydrate limits.
     * @param  integer     $maxcalories     Optional parameter: The maximum number of calories the recipe can have.
     * @param  integer     $maxcarbs        Optional parameter: The maximum number of carbohydrates in grams the recipe can have.
     * @param  integer     $maxfat          Optional parameter: The maximum number of fat in grams the recipe can have.
     * @param  integer     $maxprotein      Optional parameter: The maximum number of protein in grams the recipe can have.
     * @param  integer     $mincalories     Optional parameter: The minimum number of calories the recipe must have.
     * @param  integer     $minCarbs        Optional parameter: The minimum number of carbohydrates in grams the recipe must have.
     * @param  integer     $minfat          Optional parameter: The minimum number of fat in grams the recipe must have.
     * @param  integer     $minProtein      Optional parameter: The minimum number of protein in grams the recipe must have.
     * @param  array  $queryParameters    Additional optional query parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function findByNutrients (
                $maxcalories = 1500,
                $maxcarbs = 100,
                $maxfat = 100,
                $maxprotein = 100,
                $mincalories = 0,
                $minCarbs = 0,
                $minfat = 0,
                $minProtein = 0,
                $queryParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/findByNutrients';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'maxcalories' => (null != $maxcalories) ? $maxcalories : 1500,
            'maxcarbs'    => (null != $maxcarbs) ? $maxcarbs : 100,
            'maxfat'      => (null != $maxfat) ? $maxfat : 100,
            'maxprotein'  => (null != $maxprotein) ? $maxprotein : 100,
            'mincalories' => (null != $mincalories) ? $mincalories : 0,
            'minCarbs'    => (null != $minCarbs) ? $minCarbs : 0,
            'minfat'      => (null != $minfat) ? $minfat : 0,
            'minProtein'  => (null != $minProtein) ? $minProtein : 0,
        ));

        //append optional parameters to the query
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, $queryParameters);

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        
    /**
     * Find recipes that use as many of the given ingredients as possible and have as little as possible missing ingredients. This is a whats in your fridge API endpoint.
     * @param  string      $ingredients      Required parameter: A comma-separated list of ingredients that the recipes should contain.
     * @param  bool        $limitLicense     Optional parameter: Whether to only show recipes with an attribution license.
     * @param  integer     $number           Optional parameter: The maximal number of recipes to return (default = 5).
     * @param  integer     $ranking          Optional parameter: Whether to maximize used ingredients (1) or minimize missing ingredients (2) first.
     * @param  array  $queryParameters    Additional optional query parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function findByIngredients (
                $ingredients,
                $limitLicense = false,
                $number = 5,
                $ranking = 1,
                $queryParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/findByIngredients';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'ingredients'  => $ingredients,
            'limitLicense' => (null != $limitLicense) ? var_export($limitLicense, true) : false,
            'number'       => (null != $number) ? $number : 5,
            'ranking'      => (null != $ranking) ? $ranking : 1,
        ));

        //append optional parameters to the query
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, $queryParameters);

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapArray($response->body, array(), new Models\FindByIngredientsModel());
    }
        
    /**
     * Create a recipe card given a recipe.
     * @param  string      $backgroundImage     Required parameter: The background image ("none","background1", or "background2").
     * @param  string      $image               Required parameter: The binary image of the recipe as jpg.
     * @param  string      $ingredients         Required parameter: The ingredient list of the recipe, one ingredient per line.
     * @param  string      $instructions        Required parameter: The instructions to make the recipe. One step per line.
     * @param  string      $mask                Required parameter: The mask to put over the recipe image ("ellipseMask", "diamondMask", "diamondMask", "starMask", "heartMask", "potMask", "fishMask").
     * @param  integer     $readyInMinutes      Required parameter: The number of minutes it takes to get the recipe on the table.
     * @param  integer     $servings            Required parameter: The number of servings that you can make from the ingredients.
     * @param  string      $title               Required parameter: The title of the recipe.
     * @param  string      $author              Optional parameter: The author of the recipe.
     * @param  string      $backgroundColor     Optional parameter: The background color on the recipe card as a hex-string.
     * @param  string      $fontColor           Optional parameter: The font color on the recipe card as a hex-string.
     * @param  string      $source              Optional parameter: The source of the recipe.
     * @param    array  $fieldParameters    Additional optional form parameters are supported by this endpoint
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createRecipeCard (
                $backgroundImage,
                $image,
                $ingredients,
                $instructions,
                $mask,
                $readyInMinutes,
                $servings,
                $title,
                $author = 'Emily Henderson',
                $backgroundColor = '#ffffff',
                $fontColor = '#333333',
                $source = 'spoonacular.com',
                $fieldParameters = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/recipes/visualizeRecipe';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'X-Mashape-Key' => Configuration::$xMashapeKey
        );

        //prepare parameters
        $_parameters = array (
            'backgroundImage' => $backgroundImage,
            'image'           => $image,
            'ingredients'     => $ingredients,
            'instructions'    => $instructions,
            'mask'            => $mask,
            'readyInMinutes'  => $readyInMinutes,
            'servings'        => $servings,
            'title'           => $title,
            'author'          => (null != $author) ? $author : 'Emily Henderson',
            'backgroundColor' => (null != $backgroundColor) ? $backgroundColor : '#ffffff',
            'fontColor'       => (null != $fontColor) ? $fontColor : '#333333',
            'source'          => (null != $source) ? $source : 'spoonacular.com'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl, $_parameters);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Form($_parameters));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse,$_httpContext);

        return $response->body;
    }
        

}